{"version":3,"sources":["/Users/markmcdermott/Desktop/emoji-tetrominos/node_modules/browser-pack/_prelude.js","/Users/markmcdermott/Desktop/emoji-tetrominos/node_modules/base64-js/lib/b64.js","/Users/markmcdermott/Desktop/emoji-tetrominos/node_modules/buffer/index.js","/Users/markmcdermott/Desktop/emoji-tetrominos/node_modules/ieee754/index.js","/Users/markmcdermott/Desktop/emoji-tetrominos/node_modules/process/browser.js","/Users/markmcdermott/Desktop/emoji-tetrominos/src/block.js","/Users/markmcdermott/Desktop/emoji-tetrominos/src/fake_f893d080.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;ACAA;AACA,mBACA;;AACA,2BACA;AACA,AACA;;wCACA,cACA,aACA,AACA;;kCACA;mCACA;oCACA;mCACA;mCACA;2CACA;4CACA,AACA;;6BACA;oCACA;uBACA,iBACA,0BACA;uBACA,kBACA,2BACA;qBACA,mBACA;8BACA,gCACA;6BACA,kBACA;6BACA,0BACA;AACA,AACA;;qCACA;0CACA,AACA;;kCACA;4BACA;AACA,AACA;;AACA;AACA;AACA;AACA;AACA;wBACA;6FACA,AACA;;AACA;6CACA,AACA;;AACA;sDACA,AACA;;kBACA,AACA;;2BACA;uBACA;AACA,AACA;;oDACA;yIACA;qCACA;mCACA;uBACA;AACA,AACA;;kCACA;4EACA;uBACA;yCACA;8GACA;4BACA;uBACA;AACA,AACA;;iBACA;AACA,AACA;;sCACA;cACA;;cACA;mBACA;;cACA,AACA;;+BACA;iCACA;AACA,AACA;;wCACA;gHACA;AACA,AACA;;AACA;8EACA;sEACA;sCACA;AACA,AACA;;AACA;kBACA;iBACA;0CACA;uCACA;2CACA;wBACA;AACA;iBACA;2EACA;uCACA;2CACA;2CACA;wBACA;AACA,AACA,AACA;;;iBACA;AACA,AACA;;8BACA;gCACA;+DACA,AACA;;;AC9HA;AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;AACA;AACA,4BACA;;AACA;AACA;AACA;AACA,wBACA;;AACA,AACA,AACA,AACA,AACA;;;;;AACA,2CACA;AACA;AACA;AACA;AACA;AACA;YACA;oCACA;mCACA;;;AACA;4BACA,6CACA;oBACA;iBACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;;;;;AACA,iDACA;8BACA,8CACA,AACA;;0BACA,AACA;;AACA;AACA;wDACA;+BACA;2CACA;gCACA;AACA;AACA,AACA;;AACA;YACA;qBACA,0BACA,2BACA,8CACA,4BACA,2CACA,AACA;6BACA,AACA;;YACA;oCACA;AACA;+CACA;eACA;AACA;gBACA;uBACA;0BACA;AACA,AACA;;YACA;8EACA;AACA;mBACA;wCACA;AACA;uCACA;gCACA,qCACA,AACA,yBACA;AACA;sCACA;gCACA;4EACA;uCACA;qBACA;AACA;AACA,AACA;;eACA;AACA;;AACA;AACA,AACA;;AACA,8CACA;iCACA;eACA;eACA;eACA;eACA;eACA;eACA;eACA;eACA;eACA;eACA;eACA;mBACA;AACA;mBACA,AACA;;AACA;;AACA,qCACA;qDACA;AACA;;AACA,mDACA;YACA;oBACA;4BACA;eACA;+BACA;AACA;eACA;eACA;mCACA;AACA;eACA;eACA;eACA;sBACA;AACA;eACA;qCACA;AACA;eACA;eACA;eACA;eACA;+BACA;AACA;AACA;4BACA,AACA;;eACA;AACA;;AACA,mDACA;8BACA,gDACA,AACA;;+BACA;4BACA;sCACA;sBACA;AACA,AACA;;YACA;6CACA;wBACA;4CACA;mCACA;AACA;AACA,AACA;;6BACA;kBACA;0CACA;0BACA;yBACA;sBACA;AACA;eACA;AACA;;AACA;AACA,AACA;;AACA,sDACA;mCACA;qCACA;qBACA;mBACA;eACA;0BACA;kCACA;qBACA;AACA;AACA,AACA;;AACA;4BACA;iCACA,AACA;;iCACA;4BACA;AACA;yCACA;uDACA;+BACA;4BACA;AACA;mCACA;eACA;AACA;;AACA,uDACA;kCACA,6DACA;eACA;AACA;;AACA,wDACA;kCACA,8DACA;eACA;AACA;;AACA,yDACA;gDACA;AACA;;AACA,yDACA;kCACA,+DACA;eACA;AACA;;AACA,0DACA;kCACA,gEACA;eACA;AACA;;AACA,2EACA;AACA;AACA;8BACA;iCACA;uBACA;qBACA;AACA;;AACA;qBACA;qBACA;mBACA;mBACA;AACA,AACA;;mCACA;sCACA;qBACA;mBACA;eACA;0BACA;kCACA;qBACA;AACA;AACA;8CACA,AACA;;YACA;gBACA;eACA;kDACA;AACA;eACA;eACA;mDACA;AACA;eACA;oDACA;AACA;eACA;qDACA;AACA;eACA;qDACA;AACA;eACA;eACA;eACA;eACA;sDACA;AACA;AACA;4BACA,AACA;;eACA;AACA;;AACA,kEACA;mBACA,AACA;;8CACA;iCACA;sBACA,mBACA,kBACA,AACA;;AACA;oBACA,cACA,AACA;;YACA;gBACA;eACA;yCACA;AACA;eACA;eACA;0CACA;AACA;eACA;2CACA;AACA;eACA;4CACA;AACA;eACA;4CACA;AACA;eACA;eACA;eACA;eACA;6CACA;AACA;AACA;4BACA,AACA;;eACA;AACA;;AACA,4CACA;;gBAEA;8DACA,AACA;AAHA;AAIA;;AACA;AACA,0EACA;qBACA,AACA;;4BACA;0CACA;0CACA,AACA;;AACA;2BACA;wDACA,AACA;;AACA;6BACA;0DACA,QACA;oDACA;iDACA,AACA;;AACA;uBACA,mBACA;iDACA,4CACA,AACA;;wBACA,AACA;;kDACA;mCACA,yCACA;eACA;yDACA;AACA;AACA;;AACA,6CACA;+CACA;sCACA;eACA;uDACA;AACA;AACA;;AACA,2CACA;kBACA;kBACA;mCACA,AACA;;0CACA;8BACA;iEACA;kBACA;iBACA;yCACA;AACA;AACA,AACA;;oCACA;AACA;;AACA,4CACA;kBACA;mCACA,AACA;;qCACA,oCACA;eACA;AACA;;AACA,6CACA;uCACA;AACA;;AACA,0CACA;sBACA,AACA;;yCACA;gDACA,AACA;;kBACA;0CACA;2BACA;AACA;eACA;AACA;;AACA,8CACA;qCACA;kBACA;kDACA;+DACA;AACA;eACA;AACA;;AACA,qDACA;uBACA;kCACA;8BACA,AACA;;oCACA;sDACA;eACA;+BACA;uDACA;6CACA;iCACA;AACA;iBACA;AACA;AACA;;AACA;AACA,+CACA;oBACA;8BACA;AACA;;AACA;AACA,kDACA;oBACA;kCACA;AACA;;AACA,+DACA;uBACA;0DACA;uCACA;AACA,AACA;;2BACA,QACA,AACA;;oBACA;AACA;;AACA,gEACA;uBACA;oDACA;0DACA;0CACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;YACA;0BACA;oBACA;2BACA,+BACA;eACA;+BACA;2BACA,yBACA;AACA;eACA;AACA;;AACA,kEACA;+CACA;AACA;;AACA,kEACA;gDACA;AACA;;AACA,gEACA;uBACA;oDACA;0DACA;0CACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;YACA;0BACA;2BACA,8BACA;2BACA,+BACA;qBACA;2BACA,4CACA;eACA;2BACA,8BACA;2BACA,+BACA;2BACA,yBACA;6CACA;AACA;eACA;AACA;;AACA,kEACA;+CACA;AACA;;AACA,kEACA;gDACA;AACA;;AACA,8DACA;uBACA;oDACA,MACA;uCACA;AACA,AACA;;2BACA,QACA,AACA;;iCACA;YACA,yCACA,AACA,mBACA;AACA;;AACA,+DACA;uBACA;oDACA;0DACA;0CACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;yDACA;wBACA;YACA,kCACA,AACA,cACA;AACA;;AACA,iEACA;8CACA;AACA;;AACA,iEACA;+CACA;AACA;;AACA,+DACA;uBACA;oDACA;0DACA;0CACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;yDACA;wBACA;YACA,sCACA,AACA,cACA;AACA;;AACA,iEACA;8CACA;AACA;;AACA,iEACA;+CACA;AACA;;AACA,+DACA;uBACA;oDACA;0CACA;AACA,AACA;;2DACA;AACA;;AACA,iEACA;8CACA;AACA;;AACA,iEACA;+CACA;AACA;;AACA,gEACA;uBACA;oDACA;0CACA;AACA,AACA;;2DACA;AACA;;AACA,kEACA;+CACA;AACA;;AACA,kEACA;gDACA;AACA;;AACA,uEACA;uBACA;wDACA;0DACA;uCACA;2BACA;AACA,AACA;;mCACA,AACA;;uBACA;AACA;;AACA,wEACA;uBACA;wDACA;oDACA;0DACA;0CACA;2BACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;mEACA;uBACA,kDACA,qCACA;AACA;AACA;;AACA,0EACA;gDACA;AACA;;AACA,0EACA;iDACA;AACA;;AACA,wEACA;uBACA;wDACA;oDACA;0DACA;0CACA;2BACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;mEACA;uBACA,gDACA;AACA;AACA;;AACA,0EACA;gDACA;AACA;;AACA,0EACA;iDACA;AACA;;AACA,sEACA;uBACA;wDACA;0DACA;uCACA;kCACA;AACA,AACA;;2BACA,QACA,AACA;;qBACA,kCACA,AACA,yDACA;AACA;;AACA,uEACA;uBACA;wDACA;oDACA;0DACA;0CACA;oCACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;qBACA,kDACA,AACA,2EACA;AACA;;AACA,yEACA;+CACA;AACA;;AACA,yEACA;gDACA;AACA;;AACA,uEACA;uBACA;wDACA;oDACA;0DACA;0CACA;wCACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;qBACA,kDACA,AACA,+EACA;AACA;;AACA,yEACA;+CACA;AACA;;AACA,yEACA;gDACA;AACA;;AACA,uEACA;uBACA;wDACA;oDACA;0DACA;0CACA;uDACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;4DACA;AACA;;AACA,yEACA;+CACA;AACA;;AACA,yEACA;gDACA;AACA;;AACA,wEACA;uBACA;wDACA;oDACA;0DACA;kCACA,QACA;wDACA;AACA,AACA;;sBACA;sBACA,KACA,AACA;;4DACA;AACA;;AACA,0EACA;gDACA;AACA;;AACA,0EACA;iDACA;AACA;;AACA;AACA,2DACA;4BACA;4BACA;6BACA,AACA;;uCACA;mCACA;AACA,AACA;;2DACA;6BACA,AACA;;AACA;2BACA;+BACA,AACA;;kDACA;+CACA,AACA;;0CACA;oBACA;AACA;AACA;;AACA,6CACA;kBACA;uBACA;sCACA;8BACA;+CACA;yBACA;AACA;AACA;AACA;4CACA;AACA;;AACA,AACA,AACA,AACA;;;;AACA,mDACA;+CACA;sCACA;oCACA;iBACA;0CACA;4DACA,iBACA;uBACA;AACA;eACA;0BACA;AACA;AACA;;AACA;AACA,AACA;;AACA,+BACA;iCACA;yCACA;AACA;;AACA,sBACA;;AACA,AACA,AACA;;;AACA,uCACA;wBACA,AACA;;AACA;uBACA;uBACA,AACA;;AACA;qBACA;qBACA,AACA;;uBACA;0BACA;gCACA;wBACA;sBACA;uBACA;2BACA;8BACA;8BACA;8BACA;8BACA;0BACA;6BACA;6BACA;6BACA;6BACA;6BACA;6BACA;8BACA;8BACA;4BACA;+BACA;+BACA;+BACA;+BACA;2BACA;8BACA;8BACA;8BACA;8BACA;8BACA;8BACA;+BACA;+BACA;sBACA;yBACA;+BACA,AACA;;eACA;AACA;;AACA;AACA;8CAEA;wBADA,CAEA;iCACA;+BACA;iBACA;+BACA;eACA;AACA;;AACA,8BACA;AACA;AACA;AACA;8BACA;gCACA;AACA;;AACA,gCACA;oDACA;6DACA;WACA;AACA;;AACA,mCACA;mDACA,0CACA,sCACA;AACA;;AACA,wBACA;4CACA;0BACA;AACA;;AACA,gCACA;wBACA;6CACA;iCACA;mBACA,oCACA,SACA;wBACA;4CACA;gFACA;0CACA,mCACA;AACA;AACA;eACA;AACA;;AACA,iCACA;wBACA;6CACA;AACA;6CACA;AACA;eACA;AACA;;AACA,mCACA;mBACA;wBACA;6CACA;6BACA;oBACA;mBACA;yBACA;yBACA;AACA,AACA;;eACA;AACA;;AACA,kCACA;kCACA;AACA;;AACA,oDACA;YACA;yCACA;mDACA,QACA;gCACA;AACA;eACA;AACA;;AACA,mCACA;YACA;oCACA;sBACA;8CACA;AACA;AACA;;AACA,AACA,AACA,AACA,AACA;;;;;AACA,qCACA;0CACA;2BACA;6BACA;4CACA;AACA;;AACA,0CACA;0CACA;6BACA;6BACA;4CACA;AACA;;AACA,6CACA;0CACA;6BACA;6BACA;AACA;;AACA,qCACA;8CACA;AACA,AACA;;;ACvlCA;AACA,mEACA;eACA;uCACA;iCACA;4BACA;qBACA;oCACA;4BACA;gCACA,AACA;;aACA,AACA;;gCACA;eACA;iBACA;iFACA,AACA;;gCACA;eACA;iBACA;iFACA,AACA;;qBACA;kBACA;+BACA;0CACA;eACA;8BACA;kBACA;AACA;kDACA;AACA;;AACA,2EACA;kBACA;uCACA;iCACA;4BACA;qEACA;oCACA;4BACA;gEACA,AACA;;yBACA,AACA;;gDACA;iCACA;cACA;eACA;gDACA;iDACA;AACA;iBACA;AACA;8BACA;0BACA;iBACA;0CACA;AACA;8BACA;AACA;iBACA;AACA,AACA;;iCACA;gBACA;gBACA;qCACA;8CACA;oBACA;iBACA;6DACA;gBACA;AACA;AACA,AACA;;uFACA,AACA;;wBACA;gBACA;sFACA,AACA;;sCACA;AACA,AACA;;;ACtFA;AACA,AACA;;AACA,qCACA;;AACA,qCACA;gDACA,sBACA;wCACA,4CACA,AACA,AACA;;6BACA;;;AACA;AACA,AACA;;qBACA;sBACA;2DACA;4BACA;sFACA;iBACA;oCACA;+BACA;AACA;AACA;AACA;aACA,AACA;;uCACA;uBACA;+CACA;AACA;AACA,AACA;;qCACA;yBACA;AACA;AACA;;AACA;AACA;AACA;AACA,qBACA;;AACA,uBACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBACA;;AACA,wCACA;wBACA;AACA;;AACA;AACA;;;AACA,qCACA;wBACA;AACA,AACA;;;ACjEA;AACA;AACA;AACA,AACA;;AACA;AACA;AACA;AACA;AACA;AACA,AACA;;AACA;AACA;AACA,AACA,AACA;;;AACA;;AAGA;+BACA,GACA;+BACA;yCACA;AACA,AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;iEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;8CACA,mCACA,mCACA,sCACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;yFACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA;;AACA;qBACA;yFACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA,AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;qEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;8CACA,mCACA,mCACA,sCACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;qFACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;yEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;iDACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;6EACA;AACA,AACA;;AACA;qBACA;6EACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;yEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;iDACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;6EACA;AACA,AACA;;AACA;qBACA;yFACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;qEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;8CACA,mCACA,mCACA,sCACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;iFACA;AACA,AACA;;AACA;qBACA;iFACA;AACA,AACA;;AACA;qBACA;6EACA;AACA,AACA;;AACA;qBACA;qFACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;iEACA;oCACA,AACA;;AACA;mCACA;mCACA,AACA;;AACA;8CACA,sCACA;AACA;AACA,AACA;;iCACA,AACA;;AACA;0DACA,AACA;;AACA;2BACA,AACA;;AACA;qBACA;yFACA;AACA,AACA;;AACA;qBACA;yFACA;AACA,AACA,AACA,AACA;;;AACA,AACA;AACA;AACA,AACA;;AACA;kBACA,GACA;2BACA;0BACA;2BACA;gCACA;uBACA;qEACA;oCACA;AACA;AACA;AACA,AACA,AACA,AACA;;AAjVA,AACA;;;ACnBA;AACA,0BACA;;AACA;;AAGA;+CACA;sCACA;gCACA,AACA;;;AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;AACA;AACA;2BACA;oBACA;oBACA;;AACA;oBACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AACA;;;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;;;iBACA,6BACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,AACA,AACA;;AACA,AACA;;AACA;AACA;AACA,AACA,AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;kDACA;2CACA;AACA;AACA;AACA;AACA;uBACA;qEACA;AACA,AACA;;AACA;AACA;AACA,AACA;;AACA;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA,AACA;;iBACA,gBACA;AACA;uCACA;AACA;AACA;AACA;oCACA;4BACA;2CACA;wCACA;4BACA;AACA;AACA;2BACA;AACA;6CACA;iCACA;AACA,AACA;;AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;;;;;;iDACA;+CACA;4CACA;mDACA;qCACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AACA;;AACA;4BACA,AACA;;4BACA,AACA;;AACA;gCACA;4FACA;uDACA;gCACA;AACA;AACA,AACA;;AACA;AACA;4BACA;gCACA;sDACA;+BACA;4CACA;8BACA;AACA;AACA;AACA,AACA;;AACA;4CACA;sDACA;+BACA;6BACA;yBACA;AACA;4CACA;AACA;6BACA;qBACA;mBACA;AACA;mEACA;0CACA;AACA;AACA;AACA;iBACA;AACA,AACA;;qCACA,AACA;;oCACA;AACA;oDACA;mCACA,AACA;;AACA;AACA;8BACA;sDACA;+BACA;qCACA;AACA;8CACA;gCACA;AACA;AACA;AACA,AACA;;8BACA;qEACA;4CACA;AACA,AACA;AACA,AACA;AACA;AACA,AACA;;qCACA,AACA;;AACA;AACA;6CACA;4DACA;kCACA,AACA;;AACA;AACA;8BACA;sDACA;+BACA;qCACA;8CACA;gCACA;AACA;AACA;AACA,AACA;;8BACA;qEACA;4CACA;AACA;AACA,AACA;AACA;AACA,AACA;AACA,AACA;;AACA;0BACA;AACA;uBACA;AACA,AACA;;AACA;8BACA;+CACA;AACA,AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AACA;;iCACA;AACA;cACA;kBACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA;iBACA;AACA;sBACA;AACA,AACA;;AACA;iBACA;AACA,AACA;;AACA;AACA;8BACA;kDACA;uDACA;sCACA;AACA;+CACA;AACA;AACA;2BACA;mDACA;AACA;AACA;AACA;AACA,AACA;;oCACA;4BACA;AACA;AACA,mCACA,qBACA,qBACA,AACA;AACA;AACA,AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AACA;;sCACA;AACA;yCACA;+BACA;AACA;AACA;AACA;mCACA;4CACA;qBACA;AACA;AACA;iBACA;AACA,AACA;;gCACA;AACA;kCACA;4BACA;AACA;uBACA;AACA;0CACA;AACA;uBACA;AACA;AACA;AACA,AACA;;AACA;AACA;AACA;AACA;AACA;8BACA,AACA;;cACA;cACA;sDACA,AACA;;kBACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA;;iBACA;0BACA;mDACA;AACA,AACA,AACA,AACA;;;;oBACA;iDACA;AACA,AACA,AACA,AACA;;AACA;uCACA,AACA;;6BACA;AACA;AACA,AACA;;AACA;kBACA,AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;uBACA;AACA;;AACA;uBACA;AACA,AACA,AACA;;AACA,AACA;;AACA;AACA;AACA;AACA,AACA;;AACA;wBACA;AACA;oDACA;AACA;oBACA;yCACA;2CACA;+BACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;gCACA;AACA,AACA,AACA,AACA;;AACA;AACA;AACA;AACA,AACA;;AACA;0CACA;6BACA;AACA,AACA,AACA,AACA,AACA;;AACA;AACA;eApiBA,AACA,CAoiBA,AACA,AACA,AACA;;AACA,AACA","file":"emoji-tetrominos.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../node_modules/base64-js/lib/b64.js\",\"/../node_modules/base64-js/lib\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `Buffer._useTypedArrays`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (compatible down to IE6)\n */\nBuffer._useTypedArrays = (function () {\n  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,\n  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding\n  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support\n  // because we need to be able to add all the node Buffer API methods. This is an issue\n  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() &&\n        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Workaround: node's base64 implementation allows for non-padded strings\n  // while base64-js does not.\n  if (encoding === 'base64' && type === 'string') {\n    subject = stringtrim(subject)\n    while (subject.length % 4 !== 0) {\n      subject = subject + '='\n    }\n  }\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = coerce(subject)\n  else if (type === 'string')\n    length = Buffer.byteLength(subject, encoding)\n  else if (type === 'object')\n    length = coerce(subject.length) // assume that object is array-like\n  else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (Buffer._useTypedArrays) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    for (i = 0; i < length; i++) {\n      if (Buffer.isBuffer(subject))\n        buf[i] = subject.readUInt8(i)\n      else\n        buf[i] = subject[i]\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b !== null && b !== undefined && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\\n' +\n      'list should be an Array.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (typeof totalLength !== 'number') {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction _hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  Buffer._charsWritten = i * 2\n  return i\n}\n\nfunction _utf8Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _asciiWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _binaryWrite (buf, string, offset, length) {\n  return _asciiWrite(buf, string, offset, length)\n}\n\nfunction _base64Write (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction _utf16leWrite (buf, string, offset, length) {\n  var charsWritten = Buffer._charsWritten =\n    blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = _asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = _binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = _base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end !== undefined)\n    ? Number(end)\n    : end = self.length\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = _hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = _utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = _asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = _binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = _base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = _utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !Buffer._useTypedArrays) {\n    for (var i = 0; i < len; i++)\n      target[i + target_start] = this[i + start]\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction _base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction _utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction _asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++)\n    ret += String.fromCharCode(buf[i])\n  return ret\n}\n\nfunction _binarySlice (buf, start, end) {\n  return _asciiSlice(buf, start, end)\n}\n\nfunction _hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction _utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = clamp(start, len, 0)\n  end = clamp(end, len, len)\n\n  if (Buffer._useTypedArrays) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction _readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return _readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return _readUInt16(this, offset, false, noAssert)\n}\n\nfunction _readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return _readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return _readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction _readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return _readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return _readInt16(this, offset, false, noAssert)\n}\n\nfunction _readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = _readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return _readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return _readInt32(this, offset, false, noAssert)\n}\n\nfunction _readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return _readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return _readFloat(this, offset, false, noAssert)\n}\n\nfunction _readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return _readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return _readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n}\n\nfunction _writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  _writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  _writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n}\n\nfunction _writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  _writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction _writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    _writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  _writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction _writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  _writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction _writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  _writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0)\n  }\n\n  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  for (var i = start; i < end; i++) {\n    this[i] = value\n  }\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer._useTypedArrays) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1)\n        buf[i] = this[i]\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\n// slice(start, end)\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction coerce (length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length)\n  return length < 0 ? 0 : length\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F)\n      byteArray.push(str.charCodeAt(i))\n    else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16))\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  var pos\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../node_modules/buffer/index.js\",\"/../node_modules/buffer\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../node_modules/ieee754/index.js\",\"/../node_modules/ieee754\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/../node_modules/process/browser.js\",\"/../node_modules/process\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\n// -------------------------------------------------------------\n// --------------------- Block Class ---------------------------\n// -------------------------------------------------------------\n\n// Blocks have letter name: I, T, J, L & O (http://i.imgur.com/9Z0oJXe.png)\n// All block movement/collision calculated from block coordiates\n// Blocks are made of 4 \"pixels\"\n// First block \"pixel\" is top left pixel\n// Subsequent block coordinates are calculated from first pixel\n// Rotations based on NES Tetris (http://imgur.com/a/IVRrf)\n\n// For collision detection, make first coordinate pair in coords\n// array the block's far left pixel.  Make the last coorinate\n// coordinate pair the far right pixel.\n\n\nmodule.exports = class Block {\n\n  // block constructor (needs block letter & initial coords)\n  constructor(letter, x, y)\n  {\n    this.letter = letter.toUpperCase();\n    this[`_init${this.letter}`](x, y);\n  }\n\n\n    // init L block (needs its initial coords)\n    _initL(x, y)\n    {\n      this.height = 2;       // L block height (for floor/block collision)\n      this.width = 3;        // L block width (for wall collision)\n      this.numPix = 4;       // num pixels in L block\n      this.curRotation = 0;  // current pos in rotations array\n      this.emoji = \"😀\";\n      this.coords = [ [ x, y ], [ x, y + 1 ], [ x + 1, y ], [ x + 2, y ]  ];\n      this.rotate = function() {\n\n        // gets current x & y\n        let x = this.coords[0][0];\n        let y = this.coords[0][1];\n\n        // if L is vert, checks for collisions\n        if ( (this.curRotation === 0 && y < 1)\n           || (this.curRotation === 1 && x < 1)\n           || (this.curRotation === 1 && x > 7)\n           || (this.curRotation === 3 && x < 1) ) {\n          return;\n        }\n\n        if ( (x >= 0) && (x < 9) ) {\n\n          // advances curRotation (always 0 or 1)\n          this.curRotation = (this.curRotation + 1) % 4;\n\n          // rotates to new curRotation\n          switch(this.curRotation) {\n\n            /* down facing L block */\n            case 0:\n              this.coords = [ [ x - 1, y + 1 ], [ x, y + 1 ], [ x + 1, y + 1 ], [ x - 1, y + 2 ] ];\n              break;\n\n            /* left facing L block */\n            case 1:\n              this.coords = [ [ x, y - 1 ], [ x + 1, y - 1], [ x + 1, y ], [ x + 1, y + 1 ]  ];\n              break;\n\n            /* up facing L block */\n            case 2:\n              this.coords = [ [ x, y + 1 ], [ x + 1, y + 1 ], [ x + 2, y + 1 ], [ x + 2, y ]  ];\n              break;\n\n            /* right facing L block */\n            case 3:\n              this.coords = [ [ x + 1, y - 1 ], [ x + 1, y ], [ x + 1, y + 1 ], [ x + 2, y + 1 ]  ];\n              break;\n\n          }\n\n        }\n\n      };\n    }\n\n\n\n  // init J block (needs its initial coords)\n  _initJ(x, y)\n  {\n    this.height = 2;       // J block height (for floor/block collision)\n    this.width = 3;        // J block width (for wall collision)\n    this.numPix = 4;       // num pixels in J block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"😈\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x + 2, y ], [ x + 2, y + 1 ]  ];\n    this.rotate = function() {\n\n      // gets current x & y\n      let x = this.coords[0][0];\n      let y = this.coords[0][1];\n\n      // if J is vert, checks for collisions\n      if ( (this.curRotation === 0 && y < 1)\n         || (this.curRotation === 1 && x < 1)\n         || (this.curRotation === 1 && x > 7)\n         || (this.curRotation === 3 && x < 1) ) {\n        return;\n      }\n\n      if ( (x >= 0) && (x < 9) ) {\n\n        // advances curRotation (always 0 or 1)\n        this.curRotation = (this.curRotation + 1) % 4;\n\n        // rotates to new curRotation\n        switch(this.curRotation) {\n\n          /* down facing J block */\n          case 0:\n            this.coords = [ [ x - 1, y - 1 ], [ x, y - 1 ], [ x + 1, y - 1 ], [ x + 1, y ] ];\n            break;\n\n          /* left facing J block */\n          case 1:\n            this.coords = [ [ x, y + 1 ], [ x + 1, y + 1], [ x + 1, y ], [ x + 1, y - 1 ]  ];\n            break;\n\n          /* up facing J block */\n          case 2:\n            this.coords = [ [ x, y - 2 ], [ x, y - 1 ], [ x + 1, y - 1 ], [ x + 2, y - 1 ]  ];\n            break;\n\n          /* right facing J block */\n          case 3:\n            this.coords = [ [ x + 1, y + 2 ], [ x + 1, y + 1 ], [ x + 1, y ], [ x + 2, y ]  ];\n            break;\n\n        }\n\n      }\n\n    };\n  }\n\n  // init Z block (needs its initial coords)\n  _initZ(x, y)\n  {\n    this.height = 2;       // Z block height (for floor/block collision)\n    this.width = 3;        // Z block width (for wall collision)\n    this.numPix = 4;       // num pixels in Z block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"🚴🏿\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x + 1, y + 1 ], [ x + 2, y + 1 ] ];\n    this.rotate = function() {\n\n      // gets current x & y\n      let x = this.coords[0][0];\n      let y = this.coords[0][1];\n\n      // if Z is vert, checks for collisions\n      if (this.curRotation === 0 && y < 1) {\n        return;\n      }\n\n      if ( (x >= 0) && (x < 9) ) {\n\n        // advances curRotation (always 0 or 1)\n        this.curRotation = (this.curRotation + 1) % 2;\n\n        // rotates to new curRotation\n        switch(this.curRotation) {\n\n          /* down facing Z block */\n          case 0:\n            this.coords = [ [ x, y ], [ x - 1, y ], [ x, y + 1 ], [ x + 1, y + 1] ];\n            break;\n\n          /* vert Z block */\n          case 1:\n            this.coords = [ [ x, y ], [ x, y + 1 ], [ x + 1, y ], [ x + 1, y - 1 ] ];\n            break;\n\n        }\n\n      }\n\n    };\n  }\n\n  // init S block (needs its initial coords)\n  _initS(x, y)\n  {\n    this.height = 2;       // S block height (for floor/block collision)\n    this.width = 3;        // S block width (for wall collision)\n    this.numPix = 4;       // num pixels in S block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"🐮\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x + 1, y - 1 ], [ x + 2, y - 1 ] ];\n    this.rotate = function() {\n\n      // gets current x & y\n      let x = this.coords[0][0];\n      let y = this.coords[0][1];\n\n      // if S is vert, checks for collisions\n      if (this.curRotation === 0 && y < 1) {\n        return;\n      }\n\n      if ( (x >= 0) && (x < 9) ) {\n\n        // advances curRotation (always 0 or 1)\n        this.curRotation = (this.curRotation + 1) % 2;\n\n        // rotates to new curRotation\n        switch(this.curRotation) {\n\n          /* down facing S block */\n          case 0:\n            this.coords = [ [ x - 1, y + 1 ], [ x, y + 1 ], [ x, y ], [ x + 1, y ] ];\n            break;\n\n          /* vert S block */\n          case 1:\n            this.coords = [ [ x + 1, y - 1 ], [ x + 1, y - 2 ], [ x + 2, y - 1 ], [ x + 2, y ] ];\n            break;\n\n        }\n\n      }\n\n    };\n  }\n\n  // init T block (needs its initial coords)\n  _initT(x, y)\n  {\n    this.height = 2;       // T block height (for floor/block collision)\n    this.width = 3;        // T block width (for wall collision)\n    this.numPix = 4;       // num pixels in T block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"🚔\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x + 1, y + 1 ], [ x + 2, y ] ];\n    this.rotate = function() {\n\n      // gets current x & y\n      let x = this.coords[0][0];\n      let y = this.coords[0][1];\n\n      // if T is vert, checks for collisions\n      if ( (this.curRotation === 0 && y < 1)\n         || ( this.curRotation === 1 && x > 7)\n         || ( this.curRotation === 1 && x < 0)\n         || ( this.curRotation === 3 && x < 1) ) {\n        return;\n      }\n\n      if ( (x >= 0) && (x < 9) ) {\n\n        // advances curRotation (always 0 or 1)\n        this.curRotation = (this.curRotation + 1) % 4;\n\n        // rotates to new curRotation\n        switch(this.curRotation) {\n\n          /* down facing T block */\n          case 0:\n            this.coords = [ [ x - 1, y - 1 ], [ x , y - 1 ], [ x, y ], [ x + 1, y - 1 ] ];\n            break;\n\n          /* left facing T block */\n          case 1:\n            this.coords = [ [ x, y ], [ x + 1, y ], [ x + 1, y - 1 ], [ x + 1, y + 1 ] ];\n            break;\n\n          /* up facing T block */\n          case 2:\n            this.coords = [ [ x, y ], [ x + 1, y ], [ x + 1, y - 1 ], [ x + 2, y ] ];\n            break;\n\n          /* right facing T block */\n          case 3:\n            this.coords = [ [ x + 1, y + 1 ], [ x + 1, y ], [ x + 1, y - 1 ], [ x + 2, y ] ];\n            break;\n\n        }\n\n      }\n\n    };\n  }\n\n  // init I block (needs its initial coords)\n  _initI(x, y)\n  {\n    this.height = 1;       // I block height (for floor/block collision)\n    this.width = 4;        // I block width (for wall collision)\n    this.numPix = 4;       // num pixels in I block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"🚀\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x + 2, y ], [ x + 3, y ] ];\n    this.rotate = function() {\n\n      // gets current x & y\n      let x = this.coords[0][0];\n      let y = this.coords[0][1];\n\n      // if I is vert, checks for collisions\n      if ( ( ( this.curRotation === 0 ) && (y < 2) )\n         || ( (this.curRotation === 1 ) && ( x < 2 ) ) ) {\n        return;\n      }\n\n      if ( (x >= 0) && (x < 9) ) {\n\n        // advances curRotation (always 0 or 1)\n        this.curRotation = (this.curRotation + 1) % 2;\n\n        // rotates to new curRotation\n        switch(this.curRotation) {\n\n          /* vert I block */\n          case 0:\n            this.coords = [ [ x - 2 , y + 2 ], [ x - 1 , y + 2 ], [ x , y + 2 ], [ x + 1 , y + 2 ] ];\n            break;\n\n          /* horiz I block */\n          case 1:\n            this.coords = [ [ x + 2, y - 2 ], [ x + 2, y - 1 ], [ x + 2, y ], [ x + 2, y + 1 ] ];\n            break;\n\n        }\n\n      }\n\n    };\n  }\n\n  // init I block (needs its initial coords)\n  _initO(x, y)\n  {\n    this.height = 2;       // I block height (for floor/block collision)\n    this.width = 2;        // I block width (for wall collision)\n    this.numPix = 4;       // num pixels in I block\n    this.curRotation = 0;  // current pos in rotations array\n    this.emoji = \"🍆\";\n    this.coords = [ [ x, y ], [ x + 1, y ], [ x, y + 1 ], [ x + 1, y + 1 ] ];\n    this.rotate = function() {\n      // no rotation on O block;\n    };\n  }\n\n};\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/block.js\",\"/\")","(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){\nlet block = require(\"./block.js\");\n\n(function(){\n\n  // init vars\n  const canvas = document.getElementById(\"canvas\"),\n      ctx = canvas.getContext(\"2d\"),\n      canWidth = canvas.width,\n\n      /*\n\n        \"Pixel\" is unit of height/width, 1/10 width of board.\n        Each block is made of 4 pixels.\n\n      */\n\n      // frame counter (needed for block entrance timing)\n      // pixel = canWidth / 10.0;\n      pixel = canWidth / 10;\n  let frame = 0,\n      speed = 125,\n      // fontStyle = \"18px Georgia\",\n      fontStyle = \"30px Georgia\",\n      // colorI = '#1abc9c',\n      // colorT = '#e67e22',\n      // colorO = '#3498db',\n      // colorJ = '#e74c3c',\n      // colorL = '#9b59b6',\n      // colorS = '#f1c40f',\n      // colorZ = '#e97066',\n      fallingBlock,\n\n      /*\n\n        2d array of board layout for keeping track\n        of all \"landed\" blocks.\n        Landed blocks are blocks that have hit\n        the floor or hit other blocks collected at bottom.\n\n        landed array is all 0's to start, since no\n        blocks have hit the floor.  Every coordinate\n        with a landed block will gets a 1.\n\n      */\n\n      landed = [\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0,0,0,0]\n      ];\n\n      // init blocks\n\n  // function defs\n  // helper functions - draw boxes & text to correct scale\n  /*function strokeRec(x, y, w, h) {\n    ctx.strokeRect(x * pixel, y * pixel, w * pixel, h * pixel);\n  }*/\n  // function fillText(text, x, y) {\n  //   //console.log(text,x,y);\n  //   //ctx.fillStyle = color;\n  //   ctx.fillStyle = '#1abc9c';\n  //   ctx.font=\"18px Georgia\";\n  //   //ctx.fillText(\"text\", (x + 0.25) * pixel, (y + 0.75) * pixel);\n  //   //ctx.fillText(text, (0 + 0.25) * pixel, (0 + 0.75) * pixel);\n  //   ctx.fillText(text, (x + 0.25) * pixel, (y + 0.75) * pixel);\n  //   //ctx.strokeRect(x * pixel, y * pixel, w * pixel, h * pixel);\n  //   //ctx.strokeRect(0 * pixel, 0 * pixel, 1 * pixel, 1 * pixel);\n  // }\n  // function drawPixel(x, y, color) {\n  //   ctx.fillStyle = color;\n  //   ctx.fillRect(x * pixel, y * pixel, 1 * pixel, 1 * pixel);\n  // }\n  function drawBlock(coords, numPix, emoji) {\n    for (let i=0; i<numPix; i++) {\n      //ctx.fillStyle = color;\n      //ctx.fillRect(coords[i][0] * pixel, coords[i][1] * pixel, 1 * pixel, 1 * pixel);\n      // drawText(emoji) {\n      //ctx.fillStyle = '#1abc9c';\n      ctx.font=fontStyle;\n      ctx.fillText(emoji, (coords[i][0]) * pixel, (coords[i][1]) * pixel);\n      //fillText(emoji, coords[i][0] * pixel, coords[i][1] * pixel);\n\n      //}\n    }\n  }\n\n  // add a numbered grid to board.  for debugging\n  /*function makeGrid() {\n    for (let i=0; i<10; i++) {\n      strokeRec(i, 0, 1, 20);\n    }\n    for (let i=0; i<20; i++) {\n      strokeRec(0, i, 10, 1);\n    }\n    for (let i=0; i<20; i++) {\n      fillText(i, 0, i);\n    }\n    for (let i=1; i<10; i++) {\n      fillText(i, i, 0);\n    }\n  }\n  */\n\n  // can copy emoji from http://unicode.org/emoji/charts/full-emoji-list.html#1f600\n  // function drawText() {\n  //     fillText(\"😀\", 0, 0);\n  // }\n\n  function checkFullRows()\n  {\n    // check for any full rows\n    for (let i=0; i<20; i++) {\n      // goes down far left pixel from top of board to bottom\n      // if far left pixel is a landed block, then it checks\n      // that whole row to see if it's a full row ready to clear\n      if (landed[i][0] !== 0) {\n        let fullRow = true;\n        for (let j=1; j<10; j++) {\n          if (landed[i][j] === 0) {\n            fullRow = false;\n          }\n        }\n        if (fullRow) {\n          // clear the found full row\n          for (let j=0; j<10; j++) {\n            landed[i][j] = 0;\n          }\n\n          /*\n\n            not positive, but i think there's an\n            intermittant bug here leaving certain\n            pixels floating and not dropping when\n            they should be dropped down one\n\n          */\n          for (let k=i-1; k>=0; k--) {\n            for (let l=0; l<10; l++) {\n              if (landed[k][l] !== 0) {\n                landed[k+1][l] = landed[k][l];\n                landed[k][l] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // move the falling block down\n  function moveDown() {\n\n    if (fallingBlock) {\n\n      // check if block is touching bottom now\n      let touchingFloor = false;\n      for (let i=0; i<fallingBlock.coords.length && touchingFloor===false; i++) {\n        if (fallingBlock['coords'][i][1] === 19) {\n          touchingFloor = true;\n        }\n      }\n\n      // check if touching another block\n      // (this approach to collision detection from https://gamedevelopment.tutsplus.com/tutorials/implementing-tetris-collision-detection--gamedev-852 )\n      let collision = false;\n      if (!touchingFloor) {\n        for (let coords of fallingBlock.coords) {\n          const [ x, y ] = coords;\n          if (landed[ y + 1 ][ x ] !== 0) {\n            collision = true;\n          }\n        }\n      }\n\n      // if at floor or , add block's pixels to landed array\n      if (touchingFloor || collision) {\n        for (let coords of fallingBlock.coords) {\n          const [ x, y ] = coords;\n          if (y === 0) {\n            return 'boardFull';\n          }\n          landed[y][x] = fallingBlock.letter;\n        }\n        fallingBlock = null;\n        return 'cantMoveDown';\n      } else {\n        // lower the block\n        for (let i=0; i<fallingBlock.coords.length; i++) {\n          fallingBlock['coords'][i][1]++;\n        }\n      }\n    }\n    return 'movedDown';\n  }\n\n  function moveSide(direction) {\n\n    if (direction === 'left') {\n      // if not at left edge, move left\n      let firstPixel = fallingBlock['coords'][0];\n      if (firstPixel[0] > 0) {\n\n        // check if touching another block\n        // (this approach to collision detection from https://gamedevelopment.tutsplus.com/tutorials/implementing-tetris-collision-detection--gamedev-852 )\n        let collision = false;\n        for (let coords of fallingBlock.coords) {\n          const [ x, y ] = coords;\n          if ( (x > 0) && ( y >= 0) ) {\n            //console.log(x+','+y+'   '+landed[y]);\n            if (landed[ y ][ x - 1 ] !== 0) {\n              collision = true;\n            }\n          }\n        }\n\n        if (!collision) {\n          for (let i=0; i<fallingBlock.coords.length; i++) {\n            fallingBlock['coords'][i][0]--;\n          }\n\n        }\n\n      }\n    }\n\n    if (direction === 'right') {\n\n      // TODO: run this check on every pixel in block, not just last\n      // if not at right edge, move right\n      let length = fallingBlock.coords.length;\n      let lastPixel = fallingBlock['coords'][length-1];\n      if (lastPixel[0] < 9) {\n\n        // check if touching another block\n        // (this approach to collision detection from https://gamedevelopment.tutsplus.com/tutorials/implementing-tetris-collision-detection--gamedev-852 )\n        let collision = false;\n        for (let coords of fallingBlock.coords) {\n          const [ x, y ] = coords;\n          if ( (x < 9) && (y>=0) ) {\n            if (landed[ y ][ x + 1 ] !== 0) {\n              collision = true;\n            }\n          }\n        }\n\n        if (!collision) {\n          for (let i=0; i<fallingBlock.coords.length; i++) {\n            fallingBlock['coords'][i][0]++;\n          }\n        }\n\n      }\n    }\n\n  }\n\n  // rotate block\n  function rotate() {\n    // todo: add collision detection\n    fallingBlock.rotate();\n  }\n\n  // clear the whole board each frame to redraw all pieces in new pos\n  function clearBoard() {\n    ctx.clearRect(0, 0, 10 * pixel, 20 * pixel);\n  }\n\n  // function getColor(block) {\n  //   let color;\n  //   switch (block) {\n  //     case 'I':\n  //       color = colorI;\n  //       break;\n  //     case 'T':\n  //       color = colorT;\n  //       break;\n  //     case 'O':\n  //       color = colorO;\n  //       break;\n  //     case 'S':\n  //       color = colorS;\n  //       break;\n  //     case 'Z':\n  //       color = colorZ;\n  //       break;\n  //     case 'J':\n  //       color = colorJ;\n  //       break;\n  //     case 'L':\n  //       color = colorL;\n  //       break;\n  //   }\n  //   return color;\n  // }\n\n  function getEmoji(block) {\n    // let color;\n    let emoji;\n    switch (block) {\n      case 'I':\n        // color = colorI;\n        emoji = \"🚀\";\n        break;\n      case 'T':\n        // color = colorT;\n        emoji = \"🚔\";\n        break;\n      case 'O':\n        // color = colorO;\n        emoji = \"🍆\";\n        break;\n      case 'S':\n        // color = colorS;\n        emoji = \"🐮\";\n        break;\n      case 'Z':\n        // color = colorZ;\n        emoji = \"🚴🏿\";\n        break;\n      case 'J':\n        // color = colorJ;\n        emoji = \"😈\";\n        break;\n      case 'L':\n        // color = colorL;\n        emoji = \"😀\";\n        break;\n    }\n    // return color;\n    return emoji;\n  }\n\n  // draw all pieces that have hit the bottom\n  // (this set grows as new pieces hit the bottom)\n  function drawLanded() {\n    for (let i=0; i<landed.length; i++) {\n      for (let j=0; j<landed[i].length; j++) {\n        if (landed[i][j] !== 0) {\n          //let color = getColor(landed[i][j]);\n          let emoji = getEmoji(landed[i][j]);\n        //  drawPixel(j,i,color);\n        //ctx.fillStyle = '#1abc9c';\n        ctx.font=fontStyle;\n        ctx.fillText(emoji, j * pixel, i * pixel);\n        }\n      }\n    }\n  }\n\n  function drawFallingBlock() {\n    if (fallingBlock) {\n      //let color = getColor(fallingBlock.letter);\n      drawBlock(\n        fallingBlock.coords,\n        fallingBlock.numPix,\n        fallingBlock.emoji\n      );\n    }\n  }\n\n  // // check if fallen pieces have reached top\n  // // if so clear board\n  // function checkFullBoard() {\n  //   let boardFull = false;\n  //   for (let i=0; i<10; i++) {\n  //     if (landed[0][i] === 1) {\n  //       boardFull = true;\n  //     }\n  //   }\n  //   if (boardFull) {\n  //     for (let i=0; i<10; i++) {\n  //       for (let j=0; j<20; j++) {\n  //         landed[j][i] = 0;\n  //       }\n  //     }\n  //   }\n  // }\n\n  function moveDownOrNewBlock() {\n    //console.log(speed);\n    if (frame % (speed / 5) === 0) {\n      if (!fallingBlock) {\n        spawnBlock();\n      }\n    }\n    if (frame % speed === 0) {\n      if (moveDown() === 'boardFull') {\n        return 'boardFull';\n      }\n    }\n    return 'spawned';\n  }\n\n  function checkSpeedUp() {\n    //console.log(frame, speed);\n    if (frame % 1000 === 0) {\n      if (speed > 49) {\n        //console.log('a');\n        speed -= 25;\n      }\n      if (speed > 10 && speed < 50) {\n        //console.log('b');\n        speed -= 5;\n      }\n    }\n  }\n\n  // spawns new block at top\n  // (todo: x-pos will be random & will account for block width\n  //        so not over either edge)\n  // this falling var couldn't be seen by the other functions\n  // (scoping issues), so scrapping for now...\n  function spawnBlock() {\n\n    let blockType;\n    let x;\n    const numBlock = Math.floor(Math.random() * 7);\n\n    switch (numBlock) {\n\n      case 0:\n        blockType = 'i';\n        x = Math.floor(Math.random() * (10 - 3));\n        break;\n\n      case 1:\n        blockType = 'o';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n      case 2:\n        blockType = 't';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n      case 3:\n        blockType = 's';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n      case 4:\n        blockType = 'z';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n      case 5:\n        blockType = 'j';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n      case 6:\n        blockType = 'l';\n        x = Math.floor(Math.random() * (10 - 2));\n        break;\n\n    }\n\n    const y = 0;\n    fallingBlock = new block(blockType, x, y);\n  }\n\n\n\n  // process all keystrokes\n  function processKeystroke(key) {\n\n    if (!fallingBlock) {\n      return;\n    }\n\n    // move block keyboard input\n    switch (key) {\n\n      case 38:  // up arrow\n        rotate();\n        break;\n      case 40:  // down arrow\n        moveDown();\n        break;\n      case 39:  // right arrow\n        moveSide('right');\n        break;\n      case 37:  // left arrow\n        moveSide('left');\n        break;\n    }\n\n  }\n\n  // function drawOnEvent(e) {\n  //   draw();\n  //   e.preventDefault();\n  // }\n\n  // main draw loop (calls itself recursively at end)\n  function draw() {\n    checkSpeedUp();\n    if (moveDownOrNewBlock() === 'boardFull') {\n      //console.log('boardFull: ' + boardFull);\n      speed = 125;\n      for (let i=0; i<10; i++) {\n        for (let j=0; j<20; j++) {\n          landed[j][i] = 0;\n        }\n      }\n    }\n    checkFullRows();\n    clearBoard();\n    //makeGrid();\n    //drawText();\n    drawLanded();\n    drawFallingBlock();\n    frame++;\n    requestAnimationFrame(draw);\n  }\n\n\n\n  // event listeners\n  // for testing - \"next\" button below board\n  // (make sure moveDown() in draw() is uncommented)\n  //document.getElementById(\"next\").addEventListener(\"click\", drawOnEvent);\n\n  // event listener for all keystrokes\n  document.onkeydown = function(e) {\n    processKeystroke(e.keyCode);\n  };\n\n\n\n\n  // start game\n  spawnBlock();\n  draw();  // call main draw loop\n\n\n\n})();\n\n}).call(this,require(\"pBGvAp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_f893d080.js\",\"/\")"]}